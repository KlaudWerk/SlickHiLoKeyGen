/**
The MIT License (MIT)

Copyright (c) 2013 Igor Polouektov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
package com.klaudwerk.persistence

import scala.annotation._
import scala.slick.driver.JdbcProfile
import scala.slick.jdbc.JdbcBackend.{Session, Database}
import scala.slick.jdbc.{StaticQuery=>Q}
import Q.interpolation
import java.sql.SQLException

import scala.slick.lifted

/**
 * Case class for HiLo key
 * @param id - unique id (autogenerated)
 * @param hiValue  - high value
 * @param partition - partition
 * @param keySpace - key space name
 * @param ts - timestamp
 */
case class HiLo(id:Int, hiValue:Long,partition:Int, keySpace:String,ts:Long)

/**
 * Key Generator trait
 */
trait HiDbGenerator {
  this:Profile=>import profile.simple._

  /**
   * Persistent key
   * @param tag
   */
  class KeyValues(tag:Tag) extends Table[HiLo](tag,"KEY_VALUES"){
    def id=column[Int]("id",O.PrimaryKey,O.AutoInc)
    def hiValue=column[Long]("hi_value",O.NotNull)
    def partition=column[Int]("partition",O.NotNull)
    def keySpace=column[String]("key_space",O.NotNull)
    def ts=column[Long]("ts",O.NotNull)
    def * =(id, hiValue,partition,keySpace,ts) <>(HiLo.tupled, HiLo.unapply)
  }

  object keyValues extends TableQuery(new KeyValues(_)){

    def getKeyBySpaceAndPartition(space:String,partition:Int)(implicit session: scala.slick.jdbc.JdbcBackend.Session):Option[HiLo]={
      val q=for {
        k<-keyValues if (k.keySpace===space) && (k.partition===partition)
      } yield k
      q.firstOption
    }

    def insertNew(v:HiLo)(implicit session: scala.slick.jdbc.JdbcBackend.Session)={
        keyValues += v
    }

    def create()(implicit session: scala.slick.jdbc.JdbcBackend.Session)={
      keyValues.ddl.create
    }
    def drop()(implicit session: scala.slick.jdbc.JdbcBackend.Session)={
      keyValues.ddl.drop
    }

    def getDdl=keyValues.ddl
  }

  /**
   * Uodate Hi Value
   * @param session database session
   * @param id key id
   * @param keyValue hi value
   * @param ts timestamp
   */
  def updateHi(session:scala.slick.jdbc.JdbcBackend.Session,id:Int,keyValue:Long,ts:Long)={
    implicit val implSession=session
    sqlu"update KEY_VALUES set hi_value=$keyValue,ts=$ts where id=$id".execute
  }
}

/**
 * A Database-based Hi-Low Key generator provider
 * @param maxLowValue
 * @param partition
 * @param profile
 */
class HiLoKeyProvider(val maxLowValue:Int,
                      val partition:Int,
                      val keySpace:String,
                      val db:Database,
                      override val profile:JdbcProfile)
  extends HiDbGenerator with Profile {
  private def initKeyStream(startValue:(Long,Long)):Stream[(Long,Long)]=Stream.cons(startValue,
    initKeyStream(getNextValue(startValue._1,startValue._2)))
  private lazy val keyIterator=initKeyStream(getNextValue(-1,0)).iterator

  /**
   * Generate next Hi-Low key
   * @return the key value
   */
  def nextKey:Long={
    this.synchronized({
      val kv=keyIterator.next
      kv._1*maxLowValue+kv._2})
  }

  /**
   * Execute a function recursively with transaction retries
   * @param currentRetry  current retry
   * @param maxRetry      maximum number of retries
   * @param f             the function to execute
   * @tparam T            the function return type parameter
   * @return              the function result
   */
  @tailrec private def runWithTransactionRetry[T](currentRetry:Int,maxRetry:Int,f:()=>T):T={
    try {
      f()
    }
    catch {
      case e:SQLException => {
        if(!e.getSQLState.startsWith("40") ||
          currentRetry>=maxRetry) throw e
        Thread.sleep(100)
        return runWithTransactionRetry(currentRetry+1,maxRetry,f)
      }
      case e:Exception => throw e
    }
  }
  /**
   * Generates next high and low values
   * @param hiValue -  previous high value
   * @param lowValue - previous low value
   * @return generated Hi-Low pair
   */
  private def getNextValue(hiValue:Long,lowValue:Long):(Long,Long)={
    if(hiValue==Long.MaxValue)
      throw new Exception
    if(hiValue<0 || lowValue==maxLowValue-1){
      val key:(Long,Long)= runWithTransactionRetry[(Long,Long)](0,10,()=>{
        db withSession ({
          session:Session=>implicit val implSession=session
            val isolationLevel=implSession.conn.getTransactionIsolation
            implSession.conn.setTransactionIsolation(java.sql.Connection.TRANSACTION_SERIALIZABLE)
            try {
              session.withTransaction({
                val hl:Option[HiLo]= keyValues.getKeyBySpaceAndPartition(keySpace,partition)
                hl match {
                  case None=> {
                      keyValues.insertNew(HiLo(0,0,partition,keySpace,new java.util.Date().getTime))
                      (0L,0L)
                  }
                  case _=> {
                    updateHi(implSession,hl.get.id,hl.get.hiValue+1,new java.util.Date().getTime)
                    (hl.get.hiValue+1L,0L)
                  }
                }
              })
            }
            finally {
              implSession.conn.setTransactionIsolation(isolationLevel)
            }

        })
      })
      key
    }
    else {
      (hiValue,lowValue+1)
    }
  }
}
